= TANGLE: A Turing-Complete Topological Programming Language
:toc:
:source-highlighter: highlight.js
:sectnums:

== Introduction

Computation is braiding. Data flows along strands. Strands interact only at crossings.

TANGLE is an experimental, Turing-complete, topologically inspired programming language where programs are represented as tanglesâ€”isotopy classes of braided strands in 3D space. Instead of traditional control flow, computation proceeds via the braiding of data-carrying strands, with interactions occurring strictly at crossings.

Unlike conventional functional or imperative models, TANGLE treats code as physical structures: knots, links, and braids. The language leverages deep connections between topology, algebra, and computation, enabling novel reasoning about program equivalence through knot invariants like the Jones polynomial.

Despite its geometric foundation, TANGLE supports full recursion, pattern matching, and local bindingâ€”making it surprisingly expressive and computationally universal.

This project explores the frontier of spatial computing, where syntax mirrors structure, and evaluation reflects deformation.

== Key Features

    âœ… Topological Semantics: Programs are tangles; equivalence is isotopy.
    âœ… Braiding as Computation: Strand crossings define operations.
    âœ… Knot Invariant Evaluation: Compute Jones, Alexander, HOMFLY, Kauffman polynomials.
    âœ… Recursive Definitions & Pattern Matching: Enables general recursion â†’ Turing completeness.
    âœ… Algebraic Data via Braid Words: Braid sequences act like cons-lists over generators.
    âœ… Let Binding & Local Scope
    âœ… Weave Blocks: Define transformations on named strand configurations.

== Syntax Overview (EBNF Summary)

The full grammar is specified in ISO/IEC 14977 EBNF format within the source. Highlights include:
[source,ebnf]

program = { statement } ;
statement = definition | weave_block | computation | assertion ;

definition = "def", identifier, [ "(", param_list, ")" ], "=", expr ;
weave_block = "weave", input_decl, "into", expr, "yield", output_decl ;
computation = "compute", invariant, "(", expr, ")" ;
assertion = "assert", predicate ;
expr = match_expr | let_expr | pipeline ;
match_expr = "match", expr, "with", match_arm+, "end" ;
let_expr = "let", identifier, "=", expr, "in", expr ;

=== Core Operators (Precedence Ascending)

|===
| Operator | Name | Meaning | Precedence

| >>
| Pipeline
| Feed outputs into inputs
| Lowest

| +
| Connect Sum
| Join two tangles/knots
| â†‘

| .
| Vertical Stack / Cons
| Compose tangles top-to-bottom; builds braid words
| â†‘

| |
| Horizontal Lay
| Place tangles side-by-side (tensor)
| Highest
|===

=== Primary Constructs

==== Braid Literals

Represent braid group elements directly:

tangle

braid[s1, s2^-1, s1]   // Ïƒâ‚Ïƒâ‚‚â»Â¹Ïƒâ‚ â€” a trefoil precursor
braid[]                 // identity braid

Crossings

Explicit interaction between named strands:

tangle

(a > b)  // a crosses over b
(b < a)  // same as above

Twists

Apply framing or self-writhe:

tangle

(~x)     // twist on strand x

Unary Operations
Operation	Effect
close(e)	Close braid e into a link
mirror(e)	Reflect spatial orientation
reverse(e)	Reverse temporal direction (inverse braid)
simplify(e)	Apply Reidemeister moves
cap(e,f), cup(e,f)	Attach caps/cups to form closed components

== Example Programs

=== Identity Twist (Trivial Knot)

tangle

weave strands a into identity yield strands a

Simple Crossing â†’ Hopf Link

tangle

weave strands a, b into (a > b) yield strands b, a

Recursive Fibonacci Braid Generator

Using braid words as recursive data (cons-like via .):

tangle

def fib(0) = braid[]
def fib(1) = braid[s1]
def fib(n) =
  let prev = fib(n-1) in
  let prev2 = fib(n-2) in
  prev . s1 . prev2

    Note: This exploits the fact that braid words have sequential structureâ€”isomorphic to listsâ€”enabling induction.

Pattern Matching on Braid Structure

Match the internal form of a braid word (not up to isotopy):

tangle

match my_braid with
| identity          => "empty"
| s1 . rest         => "starts with sigma_1"
| s2^-1 . s1 . tail => "specific pattern"
| x                 => "something else: " + x
end

    âš ï¸ Warning: Matching is syntactic (on normal form), not semantic (up to isotopy). Use with care.

Compute Knot Invariants

tangle

compute jones( close( braid[s1, s1, s1] ) )
// Returns polynomial representation of the trefoil

compute linking( (a > b) | (c < d) )
// Computes linking number between components

Assertion Block

Verify equality under isotopy or exact match:

tangle

assert (a > b) == mirror(b < a)
assert compute writhe((~x)) == -2

Execution Model

Programs evaluate by simulating tangle evolution:

    Parse into abstract syntax tree (AST).
    Reduce using equational rules (Reidemeister moves when possible).
    Evaluate compute blocks symbolically (e.g., expand Jones polynomial).
    Match patterns structurally on normalized braid words.
    Bind variables and recurse.

Equivalence checking uses both syntactic reduction and invariant comparison.
Why "Turing Complete"?

Although based on finite braid groups, TANGLE achieves Turing completeness through:

    âœ… Recursive function definitions
    âœ… Pattern matching on braid-word structure (acting like list deconstruction)
    âœ… Unbounded recursion depth

This allows encoding of Peano arithmetic, Î¼-recursive functions, and simulation of register machinesâ€”all via braiding logic.

In essence: braid words serve as linked lists, enabling induction and unbounded state.
Applications & Research Directions

    ðŸ§® Formal verification of knot equivalences
    ðŸ”— Quantum computing analogies (via anyons, braid groups in topological QC)
    ðŸ¤– Program synthesis from topological constraints
    ðŸŽ¯ Education: visualizing abstract algebra and category theory
    ðŸŒ€ Exploring geometry as computation

Getting Started

To use TANGLE:

    Clone this repo:

Bash

git clone https://github.com/yourname/tangle-lang.git
cd tangle-lang

    Run parser/type-checker (WIP toolchain):

Bash

# Assuming a compiler exists...
./tanglec example.tgl --eval=jones

    Try editing .tgl files with syntax-aware editor support (coming soon).

License

MIT License â€“ see LICENSE.
Contributing

Contributions welcome! Especially interested in:

    Implementing invariant calculators
    Visualization tools (3D rendering of tangles)
    Type system extensions (strand typing, linear logic)
    Optimizations via braid simplification
    Interpreter backend (OCaml/Haskell/Rust)

Open issues or start discussions!
Acknowledgments

Inspired by:

    Vaughan Jones (Jones Polynomial)
    Joan Birman (Braid Groups)
    Philip Wadler (Functional Programming)
    Louis Kauffman (Diagrammatic Reasoning)

"The tangle of thought becomes the thought of tangle."

ifdef::backend-html5[]
<script> document.addEventListener("DOMContentLoaded", function() { // Optional: Add interactive viewer hook here }); </script>

endif::[]
